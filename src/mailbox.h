#ifndef MAILBOX_H
#define MAILBOX_H

#include <sys/types.h>
#include <sys/socket.h>
#include <pthread.h>

#include <string>
#include <ext/hash_set>
#include <ext/hash_map>
#include <vector>
#include <cstdint>

#include "constants.h"
#include "entity.h"
#include "entity_db.h"


namespace Game
{

	struct BulkUpdater;

	//The mailbox object:
	// Handles event dispatch and client synchronization.
	// Events which are generated by the server are sent to the client via this data structure.
	class Mailbox
	{
		friend class BulkUpdater;
	
	public:
		Mailbox();
		~Mailbox();
		
		//Player initialization functions
		void add_player(EntityID const& player_id);	
		void del_player(EntityID const& player_id);
		
		//Packet header manipulation stuff
		void set_origin(EntityID const& player_id, int o_x, int o_y, int o_z);
		void set_tick(EntityID const& player_id, uint64_t tickcount);
		
		//Event posting (TODO: Add some interfaces for bulk event posting, maybe some to accept TCLIST/TCMAP types for updating batches of entities?)
		void send_block(EntityID const& player_id, int x, int y, int z, Block b);
		void send_chat(EntityID const& player_id, std::string const& msg, bool scrub_xml = true);
		void send_entity(EntityID const& player_id, Entity const& entity);
		void send_kill(EntityID const& player_id, EntityID const& casualty);
		
		//Entity replication management
		void forget_all(EntityID const& player_id);
		void forget_entity(EntityID const& player_id, EntityID const& forgotten);
		
		//Http Event retrieval (breaks tons of abstractions, but is necessary to avoid wasteful memcpy's)
		void push_http_events(EntityID const& player_id, int socket);
		
	private:
	
		//Block update record
		struct BlockUpdate
		{
			int x, y, z;
			Block b;
		};
	
		//Entity coordinate record
		struct Coordinate
		{
			double x, y, z, pitch, yaw, roll;
		};

		//Player infomration which is maintained by the mailbox
		struct PlayerRecord
		{
			//Player's known entities
			__gnu_cxx::hash_set<uint64_t> known_entities;
			
			//Packet header data
			uint64_t	tick_count;		//Tick count (for the packet)
			int64_t o_x, o_y, o_z;			//The origin for the packet (in global coordinates)
		
			//Buffers for the different segments of the packet
			std::vector<BlockUpdate>	block_events;  	//Updates block on the client's map
			std::string					chat_log;		//Updates for client's chat buffer
			std::vector<Coordinate>		coords;			//Entity coordinate data
			std::vector<uint8_t>		eblob;			//Entity updates for client (raw binary buffer, excepting of course coordinate data)
			std::vector<EntityID>		dead_entities;	//Entities to remove from the client
		
		
			//Network interface
			int packet_len() const;							//Calculates packet length
			void net_serialize(int) const;		//Serializes the packet to the network
		
			//Resets the packet
			void clear();
			
			//Entity serialization functions
			void serialize_entity(Entity const& ent);
			void initialize_player(PlayerEntity const& ent);
			void serialize_player(PlayerEntity const& ent);
			void initialize_monster(MonsterEntity const& ent);
			void serialize_monster(MonsterEntity const& ent);
		};

		//The lock for the mailbox (TODO: Maybe implement fine grained locking for players?  would require rewriting the hash map though...)
		pthread_mutex_t	mailbox_lock;
		__gnu_cxx::hash_map<uint64_t, PlayerRecord*>	player_data;
		
		//Player database lock/access control
		struct PlayerLock
		{
			Mailbox* mailbox;
			EntityID player_id;
			
			PlayerLock(Mailbox* m, EntityID const& p) : mailbox(m), player_id(p)
			{
				pthread_mutex_lock(&mailbox->mailbox_lock);
			}
			
			~PlayerLock()
			{
				pthread_mutex_unlock(&mailbox->mailbox_lock);
			}
			
			//Retrieves a player record
			Mailbox::PlayerRecord* data()
			{
				auto iter = mailbox->player_data.find(player_id.id);
				if(iter == mailbox->player_data.end())
					return NULL;
				return (*iter).second;
			}
		};
	};
	
	//--------------------------------------------------------
	//A bulk entity update object, used to streamline the heartbeat process
	//It would probably be nicer to have this in world.cc, but it needs access
	//to private implementation details of Mailbox to perform correct locking...
	//
	//Does a sequence of updates actions at once;
	//
	// On construction:
	//	Locks player record
	//	Sets packet header
	//
	// While active:
	// 	Wraps send_entity with non-locking version
	//
	// On destruction:
	//	Serializes entity data to network
	//	Clears packet
	//
	//--------------------------------------------------------
	struct BulkUpdater
	{
		BulkUpdater(
			Mailbox* mailbox, 
			EntityID const& player_id, 
			int socket_,
			int64_t tick_count,
			double ox, double oy, double oz) : 
				player_lock(mailbox, player_id), 
				data(NULL), 
				socket(socket_)
		{
			data = player_lock.data();
			
			//Set header
			if(data)
			{	data->tick_count = tick_count;
				data->o_x = ox;
				data->o_y = oy;
				data->o_z = oz;
			}
		}
		
		~BulkUpdater()
		{
			if(data)
			{	data->net_serialize(socket);
				data->clear();
			}
		}
	
		static EntityUpdateControl send_entity(Entity& entity, void* data)
		{
			if(data)
			{
				((Mailbox::PlayerRecord*)data)->serialize_entity(entity);
			}
			
			return EntityUpdateControl::Continue;
		}
		
		void* get_data() { return (void*)data; }
	
	private:
		Mailbox::PlayerLock player_lock;
		Mailbox::PlayerRecord* data;
		int socket;
	};
	
};


#endif

