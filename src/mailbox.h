#ifndef MAILBOX_H
#define MAILBOX_H

#include <sys/types.h>
#include <sys/socket.h>
#include <pthread.h>

#include <string>
#include <set>
#include <map>
#include <vector>
#include <cstdint>

#include "constants.h"
#include "misc.h"
#include "chunk.h"
#include "entity.h"
#include "entity_db.h"

namespace Game
{

	//Forward declaration
	struct HeartbeatPoll;

	//The mailbox object:
	// Handles event dispatch and client synchronization.
	// Events which are generated by the server are sent to the client via this data structure.
	class Mailbox
	{
		friend class HeartbeatPoll;
	
	public:
		Mailbox();
		~Mailbox();
		
		//Sets the time count for the mailbox
		void set_tick_count(uint64_t t) { tick_count = t; }
		
		
		//Player initialization functions
		void add_player(EntityID const& player_id, int ox, int oy, int oz);	
		void del_player(EntityID const& player_id);
		
		//Packet header manipulation stuff
		void set_origin(EntityID const& player_id, int ox, int oy, int oz);
		
		//Targetted event posting 
		void send_block(EntityID const& player_id, int x, int y, int z, Block b);
		void send_chat(EntityID const& player_id, std::string const& msg, bool scrub_xml = true);
		void send_entity(EntityID const& player_id, Entity const& entity);
		void send_kill(EntityID const& player_id, EntityID const& casualty);
		
		//Event broadcasting
		void broadcast_block(Region const& r, int x, int y, int z, Block b);
		void broadcast_chat(Region const& r, std::string const& msg, bool scrub_xml = true);
		void broadcast_entity(Region const& r, Entity const& entity);
		void broadcast_kill(Region const& r, EntityID const& casualty);
		
		//Entity replication management
		void forget_all(EntityID const& player_id);
		void forget_entity(EntityID const& player_id, EntityID const& forgotten);
		
	private:
	
		//Local copy of the tick counter
		uint64_t 	tick_count;
	
		//Block update record
		struct BlockUpdate
		{
			int x, y, z;
			Block b;
		};
	
		//Entity coordinate record
		struct Coordinate
		{
			uint64_t t;
			double x, y, z, pitch, yaw, roll;
		};

		//Player infomration which is maintained by the mailbox
		struct PlayerRecord
		{
			//Player's known entities
			std::set<uint64_t> known_entities;
			
			//Player entity id
			EntityID player_id;
			
			//Packet header data
			uint64_t	tick_count;		//Tick count (for the packet)
			int64_t ox, oy, oz;		//The origin for the packet (in global coordinates)
		
			//Buffers for the different segments of the packet
			std::vector<BlockUpdate>	block_events;  	//Updates block on the client's map
			std::string					chat_log;		//Updates for client's chat buffer
			std::vector<Coordinate>		coords;			//Entity coordinate data
			std::vector<uint8_t>		eblob;			//Entity updates for client (binary)
			std::vector<EntityID>		dead_entities;	//Entities to remove from the client
		
			//Hash position into a bucket
		
			//Network interface
			int packet_len() const;							//Calculates packet length
			void net_serialize(int) const;		//Serializes the packet to the network
		
			//Resets the packet
			void clear();
			
			//Basic event serialization
			void serialize_block(Mailbox::BlockUpdate const& block);
			void serialize_chat(const std::string& msg, bool scrub_xml);
			void serialize_kill(EntityID const& ent);
			
			//Entity serialization functions
			void serialize_entity(Entity const& ent);
			void initialize_player(PlayerEntity const& ent);
			void serialize_player(PlayerEntity const& ent);
			void initialize_monster(MonsterEntity const& ent);
			void serialize_monster(MonsterEntity const& ent);
		};

		//The lock for the mailbox 
		// TODO: Maybe implement fine grained locking for players?  
		//	would require rewriting the hash map though...
		//Other possibility, switch to tokyo cabinet, use hash map...
		pthread_mutex_t	mailbox_lock;
		std::map<uint64_t, PlayerRecord*>	player_data;
		
		//Player database lock/access control
		struct PlayerLock
		{
			Mailbox* mailbox;
			EntityID player_id;
			
			PlayerLock(Mailbox* m, EntityID const& p) : mailbox(m), player_id(p)
			{
				pthread_mutex_lock(&mailbox->mailbox_lock);
			}
			
			~PlayerLock()
			{
				pthread_mutex_unlock(&mailbox->mailbox_lock);
			}
			
			//Retrieves a player record
			Mailbox::PlayerRecord* data()
			{
				auto iter = mailbox->player_data.find(player_id.id);
				if(iter == mailbox->player_data.end())
					return NULL;
				return (*iter).second;
			}
		};
		
		//The index for the player locations
		std::map<uint64_t, std::vector<EntityID> >	player_pos_index;
		
		//Player index functions
		std::vector<EntityID> get_player_list(Region const& r);
		void set_index(PlayerRecord* data, int ox, int oy, int oz);
		void update_index(PlayerRecord* data, int ox, int oy, int oz);
		void remove_index(PlayerRecord* data);
		void foreach_region(Region const& r, void (*post_event)(PlayerRecord*, void*), void*);
	};
	
	//--------------------------------------------------------
	//A bulk entity update object, used to streamline the heartbeat process
	//It would probably be nicer to have this in world.cc, but it needs access
	//to private implementation details of Mailbox to perform correct locking...
	//
	//Does a sequence of updates actions at once;
	//
	// On construction:
	//	Locks player record
	//	Sets packet header
	//
	// While active:
	// 	Wraps send_entity with non-locking version
	//
	// On destruction:
	//	Serializes entity data to network
	//	Clears packet
	//
	//--------------------------------------------------------
	struct HeartbeatPoll
	{
		HeartbeatPoll(
			Mailbox* mailbox, 
			EntityID const& player_id, 
			int socket_,
			double ox, double oy, double oz) : 
				player_lock(mailbox, player_id), 
				data(NULL), 
				socket(socket_)
		{
			data = player_lock.data();
			
			//Set header
			if(data)
			{
				data->tick_count = mailbox->tick_count;
				mailbox->update_index(data, (int)ox, (int)oy, (int)oz);
			}
		}
		
		~HeartbeatPoll()
		{
			if(data)
			{	data->net_serialize(socket);
				data->clear();
			}
		}
	
		static EntityUpdateControl send_entity(Entity& entity, void* data)
		{
			if(data)
			{
				((Mailbox::PlayerRecord*)data)->serialize_entity(entity);
			}
			
			return EntityUpdateControl::Continue;
		}
		
		void* get_data() { return (void*)data; }
	
	private:
		Mailbox::PlayerLock player_lock;
		Mailbox::PlayerRecord* data;
		int socket;
	};
	
};


#endif

