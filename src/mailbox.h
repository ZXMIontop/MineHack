#ifndef MAILBOX_H
#define MAILBOX_H

#include <pthread.h>

#include <string>
#include <set>
#include <map>
#include <vector>
#include <cstdint>

#include "constants.h"
#include "misc.h"
#include "chunk.h"
#include "entity.h"
#include "world.h"
#include "heartbeat.h"

namespace Game
{

	//The mailbox object:
	// Handles event dispatch and client synchronization.
	// Events which are generated by the server are sent to the client via this data structure.
	class Mailbox
	{
		friend bool heartbeat_impl(Mailbox*, EntityDB*, EntityID const&, int, int);
		
	public:
		Mailbox();
		~Mailbox();
		
		//Sets the time count for the mailbox
		void set_tick_count(uint64_t t) { tick_count = t; }
		
		
		//Player initialization functions
		void add_player(EntityID const& player_id, int ox, int oy, int oz);	
		void del_player(EntityID const& player_id);
		
		//Packet header manipulation stuff
		void set_origin(EntityID const& player_id, int ox, int oy, int oz);
		
		//Targetted event posting 
		void send_block(EntityID const& player_id, int x, int y, int z, Block b);
		void send_chat(EntityID const& player_id, std::string const& msg, bool scrub_xml = true);
		void send_entity(EntityID const& player_id, Entity const& entity);
		void send_kill(EntityID const& player_id, EntityID const& casualty);
		
		//Event broadcasting
		void broadcast_block(Region const& r, int x, int y, int z, Block b);
		void broadcast_chat(Region const& r, std::string const& msg, bool scrub_xml = true);
		void broadcast_entity(Region const& r, Entity const& entity);
		void broadcast_kill(Region const& r, EntityID const& casualty);
		
		//Chunk tracking stuff
		uint64_t get_next_vis_set(EntityID const& player_id);
		void mark_vis_set(EntityID const& player_id, uint64_t vis_id);
		
		//Entity replication management
		void forget_all(EntityID const& player_id);
		void forget_entity(EntityID const& player_id, EntityID const& forgotten);
		
	private:
	
		//Local copy of the tick counter
		uint64_t 	tick_count;
	
		//Block update record
		struct BlockUpdate
		{
			int x, y, z;
			Block b;
		};
	
		//Entity coordinate record
		struct Coordinate
		{
			uint64_t t;
			double x, y, z, pitch, yaw, roll;
		};

		//Player infomration which is maintained by the mailbox
		struct PlayerRecord
		{
			//Player's known entities
			std::set<uint64_t> known_entities;
			
			//Player's known regions
			std::set<uint64_t> known_regions;
			
			//Player entity id
			EntityID player_id;
			
			//Packet header data
			uint64_t	tick_count;		//Tick count (for the packet)
			int64_t ox, oy, oz;		//The origin for the packet (in global coordinates)
		
			//Buffers for the different segments of the packet
			std::vector<BlockUpdate>	block_events;  	//Updates block on the client's map
			std::string					chat_log;		//Updates for client's chat buffer
			std::vector<Coordinate>		coords;			//Entity coordinate data
			std::vector<uint8_t>		eblob;			//Entity updates for client (binary)
			std::vector<EntityID>		dead_entities;	//Entities to remove from the client
		
			//Network interface
			int packet_len() const;							//Calculates packet length
			void net_serialize(int) const;		//Serializes the packet to the network
		
			//Swaps contents of this packet with another
			void swap(PlayerRecord& other);
			
			//Basic event serialization
			void serialize_block(Mailbox::BlockUpdate const& block);
			void serialize_chat(const std::string& msg, bool scrub_xml);
			void serialize_kill(EntityID const& ent);
			
			//Entity serialization functions
			void serialize_entity(Entity const& ent);
			void initialize_player(PlayerEntity const& ent);
			void serialize_player(PlayerEntity const& ent);
			void initialize_monster(MonsterEntity const& ent);
			void serialize_monster(MonsterEntity const& ent);
		};

		//The lock for the mailbox 
		// TODO: Maybe implement fine grained locking for players?  
		//	would require rewriting the hash map though...
		//Other possibility, switch to tokyo cabinet, use hash map...
		pthread_mutex_t	mailbox_lock;
		std::map<uint64_t, PlayerRecord*>	player_data;
		
		//Player database lock/access control
		struct PlayerLock
		{
			Mailbox* mailbox;
			EntityID player_id;
			
			PlayerLock(Mailbox* m, EntityID const& p) : mailbox(m), player_id(p)
			{
				pthread_mutex_lock(&mailbox->mailbox_lock);
			}
			
			~PlayerLock()
			{
				pthread_mutex_unlock(&mailbox->mailbox_lock);
			}
			
			//Retrieves a player record
			Mailbox::PlayerRecord* data()
			{
				auto iter = mailbox->player_data.find(player_id.id);
				if(iter == mailbox->player_data.end())
					return NULL;
				return (*iter).second;
			}
		};
		
		//The index for the player locations
		std::map<uint64_t, std::vector<EntityID> >	player_pos_index;
		
		//Player index functions
		std::vector<EntityID> get_player_list(Region const& r);
		void set_index(PlayerRecord* data, int ox, int oy, int oz);
		void update_index(PlayerRecord* data, int ox, int oy, int oz);
		void remove_index(PlayerRecord* data);
		void foreach_region(Region const& r, void (*post_event)(PlayerRecord*, void*), void*);
	};
};


#endif

